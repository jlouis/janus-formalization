\chapter{Introduction}

The JANUS programming language were conceived as a student project in
1982 at Caltech by Chris Lutz and Howard Derby. It was first later
however, with the work in \cite{glueck+2007, glueck+2008} that
the language was given a modern formal treatment. In these papers, variants
of the language are established with operational semantics. The
results improves on earlier informal descriptions.

We study the JANUS programming language because it is an example of a
small reversible imperative language. These languages have the
interesting property that programs can be run backwards to obtain the
original input from the output of a computation. This study form the
base of programming languages for reversible CMOS technology and
quantum computing.

Usually when we add formality to a process, there is a need for
changing the original informal description. Formality enforces us to
optimize and make precise the definitions and results, which in turn
sharpens and refines our knowledge of a field. A better understanding
through formality makes it easier to gather new knowlegde in a field.

The current state-of-the-art with respect to formality is
machine-verifiable formalizations -- encoding our formal work in a way
the machine can understand. We then proceed to encode the meta-theory
of our formalization as well. Finally, we ask the machine to
systematically verify the correctness of our proofs.

The goal of this process is not to prove human beings wrong. It is
rarely the case that the checking process of ``the human grid
computer'' fails to notice errors in meta-theory. Rather, the goals
are those of simplicity, detailed understanding and domain knowledge:

When we explain a theorem to a computer, it is easiest to use simple
methods. It is more expensive to formalize a complex principle and use
it rather than taking more time and coming up with a simpler
proof. This forces us to use humility and simplicity in our work.

A proof explained to the computer can only draw on knowledge we
already told the computer. For any proof, we must be able to
explain any detail, as otherwise it will be impossible to
machine-verify.

Finally, we may hope to gain additional knowledge about the domain in
the formalization process. The precision required yield no place for
imprecision and cannot lure our intuition down the wrong path. Hence,
we often learn from the formalization process.

This DIKU graduate project establishes a full formalized semantics for
a variant of the JANUS language in the proof assistant \coq{}. The
main academic contribution of the paper is the use of syntax-driven
semantics for JANUS: Invalid programs are ruled out by having no possible
inference tree. The secondary contribution establishes the machine
verification of the main theorems of the JANUS variant.

To make the work digestible, it has been split in several subsets of
the JANUS language. First, we introduce some simplified versions,
\janusz{}, \januso{} -- before processing the complete language. It is
our hope that these subsets make it easier to understand the full
development.

The report also describes the toolbox needed for formalization in
\coq{} with the concepts introduced as they are needed.

Finally, this report is honest to the state-of-the-art: any result is
mechanically formalized and verified in \coq{}.

\subsection{Related work}

There are several examples of reversible programming languages. There
are reversible Turing machines \cite{morita+2007:reversible-tm} and
other reversible functional languages
\cite{glueck+2005:program-inverter}. There are also many examples of
programming language formalizations: Some examples of the diversity
are functional languages \cite{leroy+2009:coinductive-big-step},
substructural languages \cite{fluett+2007:phd-thesis} and foundational
languages \cite{jlouis+2007:bachelor}

To our knowledge, nobody has tried to formalize reversible programming
languages using mechanical verification tools before this project. As
such, this project combines two otherwise unrelated fields: namely the
field of mechanical verification of programming language properties
and the field of reversible language theory. We hope this will benefit
both fields.

\subsection{Expectations}

We expect the reader to be well versed in the concepts of programming
language semantics and proofs of programming language meta-theory. We
further expect the reader to know the general idea of logical
frameworks, proof assistants and theorem provers. We won't describe
the concepts of \coq{} in much detail. We will just point to the
literature \fixme{cite}.

We also expect the reader to be somewhat familiar with the concept of
reversible languages. In particular we expect the reader to know what
it means for a language to be reversible in the informal sense.

\section{Choice of formalization framework}

One might want to know what decided the formal verification framework
to use. The author has used two frameworks in the past, \coq{} and \twelf{}
and it felt logical to use one of those in the formal verification.

One has to make the choice of framework early on and then stick to
it. It is exactly like choosing a programming language for a given
task.

\coq{} is a proof assistant using an (co-)inductive variant of the
Calculus of Constructions (CoC). It relies on the Curry-Howard
correspondence to get a link between program/proof and
types/theorems. Proof are carried out by giving tactics; hints about
what to do next. These tactics then build up a term which constitutes
the proof via the Curry-Howard isomorphism. Finally, a low level type
checker makes sure the proof is correct.

\twelf{} uses a dependently typed lambda calculus constrained to
certain canonical forms. This calculus is called LF. The syntax,
semantics, and proofs are then all encoded in this LF-language. For
proof validity, separate checker then verifies certain properties on
the correctness of the proof, see \cite{harper+05:how-to-believe,
  harper+07:mechanizing}.

\coq{} supports proof automation where parts of proofs are done
automatically by the computer. However, most of the time carrying out
proofs are spent on things other than the proof structure: a
considerable amount of time is spent on figuring out how to conduct
the proof. Another time consumer is feeding the necessary prior
knowledge to the proof system for the development. You can only carry
out 32-bit addition if the system knows what a 32-bit
number is, and what addition means. Properties of JANUS relies on
properties of 32-bit addition, so this must be fed to the framework as
well.

\twelf{} does not currently support automation of proof. On the other
hand, it provides proof \emph{adequacy}: there is an isomorphism
between the proof in \twelf{} and proof on paper. In other words, any
proof can be transcribed to a standard paper proof. If one is
interested in how the proof is carried out, \twelf{} has a more direct
approach. \coq{} does not provide a proof term that is easily
digestible by a human reader.

The JANUS development needs 32-bit numbers. These were available for
\coq{}, but not for \twelf{}. One could have used classic integers of
infinite size however. \coq{} further had support for arithmetic in
libraries, whereas in \twelf{}, we would have to encode this
ourselves. On the other hand, \twelf{} has a simpler system and excels
at working with lambda-style binders through
Higher-order-abstract-syntax (HOAS). For \twelf{}, it would be
beneficial to encode the functions via HOAS, but we can't utilize HOAS
for the store where it would have been even more beneficial. \twelf{}
also has support for several mutual induction schemes. These are also
available in \coq{}, but are considerably harder to use. From \coq{}
version 8.2, some syntactic sugar has been added to make its
use easier, but it has not seen much testing yet.

It was deemed that it would be best to have easy access to 32-bit
numbers and hence \coq{} were chosen. In hindsight certain mutual
induction proofs would probably have been easier to carry out in
\twelf{} and to rely on arbitrary sized integers would not have been
detrimental to the demonstration of the findings in this report. The
author would probably have used \twelf{} should he do the task again.

\section{Reversible computation}
\label{sec:revers-comp}

Suppose we are given a program $p$ and give it an input $x$ and it
yields an output $y$:
\begin{equation*}
  |[p|](x) = y
\end{equation*}
For some programs $p$ it will be possible to reconstruct $x$ from the
pair $(p, y)$.

To achieve this inversion property certain things must be
fulfilled. The program $p$ must at least be injective: Different
inputs must map the different outputs. Otherwise it is impossible to
reconstruct the input from the output in all cases. As an example,
take the Standard ML program
\begin{verbatim}
  fun even_odd x =
    x mod 2
\end{verbatim}
which will take any number $x$ and return either $0$ or $1$. All even
numbers will be assigned to $0$ and thus it is impossible to know
which even number was the input. The program is not injective and thus
not reversible.

\begin{defn}
  A program $p$ is called \emph{information preserving} if for
  $|[p|](x) = y$ it is possible to uniquely reconstruct $x$ from the
  pair $(p, y)$.
\end{defn}
Informally, no loss of information may occur in the computation.

\begin{thm}
  Any information preserving program is injective.
\end{thm}
\begin{proof}
  Assume the program is not injective. Then we have $x \neq y$ but
  $|[p|](x) = |[p|](y)$. but then we can't uniquely reconstruct $x$
  say since $y$ is equally likely.
\end{proof}
Injectivity is a necessary condition. The wording of information
preservation is carefully chosen such that there \emph{is} an input
yielding the given output. The output space is then the image of all
possible inputs, automatically making the statement surjective on the
co-domain.

For a reversible programming language, like JANUS, we obtain the
information preservation by means of an inversion property: Any
program $p$ can be inverted into a program $p^{-1}$ with
$|[p^{-1}|](y) = x$. Thus we can always reconstruct $x$ from the pair
$(p, y)$ by inverting $p$ and inputting $y$.

JANUS is reversible because it is possible to define a term-rewriting
system for turning a program into its inverse. We will see that it is
possible since each atomic instruction is invertible and each compound
instruction is invertible if its components are. This let us use an
inductive argument to show all programs reversible.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
